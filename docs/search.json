[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Mathematical Ecology",
    "section": "",
    "text": "Introduction to Mathematical Ecology\nThese pages contain lecture notes, lab worksheets, and exercises for Mathematical Ecology.\nMy first lecture for the 3MC school on Mathematical Modelling in Biology covered material in Chapter 1 and the labs on R Chapter 2 and the GillespieSSA routines Chapter 3.\nThe pdf presentation for my second and third lectures can be found here\nThe pdf presentation for my fourth lectures can be found here"
  },
  {
    "objectID": "lec01-BirthProcess.html",
    "href": "lec01-BirthProcess.html",
    "title": "1  The Simple Death Process",
    "section": "",
    "text": "2 The Simple Birth Process\nAs a simple starting point, consider a simple population whose individuals\nLet \\(N(t)\\) be a random variable denoting the population at time \\(t\\), and let \\(p_n(t)\\) be the probability that \\(N(t) = n\\), where \\(n\\in\\{0,1,2,\\dots\\}\\). We will take time to be continuous. Assume that the probability that any individual gives birth during the short time interval \\((t,t+\\tau)\\) is independent of \\(t\\) and proportional to \\(\\tau\\) and that the probability of two births occurring in the same interval is \\(o(\\tau)\\)."
  },
  {
    "objectID": "lec01-BirthProcess.html#a-single-individual",
    "href": "lec01-BirthProcess.html#a-single-individual",
    "title": "1  The Simple Death Process",
    "section": "1.1 A single individual",
    "text": "1.1 A single individual\nLet \\(X(t)\\) be a random variable denoting the state of a given organism at time \\(t\\), with one indicating alive and zero dead.\nThe main assumptions of the simple death process are as follows:\n\nat any time, the individual is in one of two possible states, alive (1) or dead (0);\nif an individual is alive at time \\(t\\), the probability of that individual dying before time \\(t+\\tau\\) is proportional to the waiting time \\(\\tau\\) and independent of \\(t\\).\n\nWe express these assumptions precisely with statements about conditional probabilities. For every interval \\([t,t+\\tau]\\), with \\(t\\) and \\(\\tau\\) nonnegative, we assume that \\[\\text{Pr}\\left(\\  X(t+\\tau)=0  \\ \\mid\\  X(t)=1 \\ \\right) = \\mu\\tau + o(\\tau). \\tag{1.1}\\]\nLittle-o, \\(o(\\tau)\\), is a mathematical shorthand for negligible. Technically, we say a function, \\(f(\\tau)\\) is \\(o(\\tau^k)\\) if \\(\\displaystyle\\lim_{t\\to0} \\dfrac{f(\\tau)}{\\tau^k} = 0\\). That is, \\(f\\) goes to zero faster than \\(\\tau^k\\)."
  },
  {
    "objectID": "lec01-BirthProcess.html#event-times",
    "href": "lec01-BirthProcess.html#event-times",
    "title": "1  The Simple Death Process",
    "section": "1.2 Event times",
    "text": "1.2 Event times\nConsider again a single individual alive at time zero, and let \\(T\\) be the random variable denoting the time the individual dies. From Equation 1.1, we know that the probability the organism dies between times \\(t\\) and \\(t+\\tau\\) must be \\[\\text{Pr}\\left(\\  T\\in (t,t+\\tau]  \\ \\mid\\  T&gt;t \\ \\right) = \\mu\\tau + o(\\tau).\\] From the definition of conditional probability and the fact that \\(\\text{Pr}\\left(\\ T&gt;t \\right)\\) is a nonincreasing function of \\(t\\), we know that \\[\\text{Pr}\\left(\\  T\\in (t,t+\\tau]  \\ \\mid\\  T&gt;t \\ \\right) = \\frac{\\text{Pr}\\left(\\ T&gt;t \\right) - \\text{Pr}\\left(\\ T&gt;t+\\tau \\right)}{\\text{Pr}\\left(\\ T&gt;t \\right)}.\\] Equating the two expressions leads to \\[\\begin{align*}\n  \\frac{\\text{Pr}\\left(\\ T&gt;t \\right) - \\text{Pr}\\left(\\ T&gt;t+\\tau \\right)}{\\text{Pr}\\left(\\ T&gt;t \\right)} &= \\mu\\tau + o(\\tau) \\\\\n  \\frac{\\text{Pr}\\left(\\ T&gt;t \\right) - \\text{Pr}\\left(\\ T&gt;t+\\tau \\right)}{\\tau} &= \\mu \\text{Pr}\\left(\\ T&gt;t \\right) + \\frac{o(\\tau)}{\\tau}\n\\end{align*}\\] Finally, taking a limit as \\(\\tau\\to0\\) leads us to a differential equation for \\(\\text{Pr}\\left(\\ T&gt;t \\right)\\). \\[\\frac{d}{dt}\\text{Pr}\\left(\\ T&gt;t \\right) = - \\lim_{\\tau\\to0}\\frac{\\text{Pr}\\left(\\ T&gt;t \\right) - \\text{Pr}\\left(\\ T&gt;t+\\tau \\right)}{\\tau} = - \\mu \\text{Pr}\\left(\\ T&gt;t \\right)\\] Solving this equation with the initial condition \\(\\text{Pr}\\left(\\ T&gt;0 \\right)=1\\), we find that \\[\\text{Pr}\\left(\\ T&gt;t \\right) = \\exp\\left(-\\displaystyle\\int_0^t \\mu(s)\\, ds\\right).\\] If the switching rate is constant, then \\(\\text{Pr}\\left(\\ T&gt;t \\right) = e^{-\\mu t}\\). That is, \\(T\\) has an exponential distribution with rate \\(\\mu\\).\nThis exponential distribution of event times, sometimes called sojourn times, persists across many compartmental models. The assumption that the mortality rate, \\(\\mu\\), is constant and does not depend on time or any aspects of the individual, such as age, implies an exponential distribution of event times with its skew towards short times.\n\nExercise 1.1 Show that the mean of the exponential distribution with rate \\(\\mu\\) is \\(\\frac{1}{\\mu}\\) and hence \\(\\mu\\) is the reciprocal of the life expectancy.\n\n\nExercise 1.2 Compute the 10th and 90th percentiles of an exponential distribution with rate \\(\\mu\\). That is, find the times \\(q\\) for which \\(\\text{Pr}\\left(\\ T&lt;q \\right) \\in \\{0.1,0.9\\}\\)\n\n\n\\[\\text{Pr}\\left(\\ T&lt;q \\right) = 1 - \\text{Pr}\\left(\\ T&gt;q \\right) = 1 - e^{-\\mu q}\\] Setting this to \\(p\\) and solving for \\(q\\) in terms of \\(p\\) leads to \\[q = -\\frac{1}{\\mu}\\log p\\] For \\(p= 0.1\\), we find \\(q\\approx\\frac{2.3}{\\mu}\\), and for \\(p=0.9\\), we find \\(q\\approx\\frac{0.1}{\\mu}\\). In other words, 10% of individuals survive at least twice as long as the mean, and 10% die before reaching one tenth the mean age."
  },
  {
    "objectID": "lec01-BirthProcess.html#a-single-individual-1",
    "href": "lec01-BirthProcess.html#a-single-individual-1",
    "title": "1  The Simple Death Process",
    "section": "2.1 A single individual",
    "text": "2.1 A single individual\nThus, in a population of a single individual, \\[\\begin{align*}\n    \\text{Pr}\\left(\\ \\text{exactly 1 birth in $[t,t+\\tau]$} \\right) &= b\\tau + o(\\tau), \\\\\n    \\text{Pr}\\left(\\ \\text{more than 1 birth in $[t,t+\\tau]$} \\right) &= o(\\tau), \\\\\n    \\text{Pr}\\left(\\ \\text{no births in $[t,t+\\tau]$} \\right) &= 1 - b\\tau + o(\\tau), \\\\\n\\end{align*}\\]\nLet \\(p_n(t)\\) be the probability the individual has \\(n\\) offspring in the interval \\((0,t)\\). From the transition probabilities specified above, \\[\\begin{align*}\n  p_{n}(t+\\tau) &= \\left(1 - b\\tau + o(\\tau)\\right)p_{n}(t) + \\left(b\\tau + o(\\tau)\\right)p_{n-1}(t), \\quad n\\in{1,2,\\dots} \\\\\n  p_0(t+\\tau)   &= \\left(1 - b\\tau + o(\\tau)\\right)p_{n}(t), \\quad n = 0.\n\\end{align*}\\]\nRearranging the terms and taking a limit as \\(\\tau\\to0\\) leads to the following system of differential equations: \\[\\begin{align*}\n  \\frac{d}{dt}p_n(t) &= -b p_{n}(t) + b p_{n-1}(t), \\quad n&gt;0, \\\\\n  \\frac{d}{dt}p_0(t) &= -b p_{0}(t). \\\\\n\\end{align*}\\]\n\nExercise 2.1 Show that the solution to the above system of differential equations with \\(p_0(0)=1\\) and \\(p_n(0) = 0\\), \\(n\\in\\{1,2,3,\\dots\\}\\) is \\[p_n(t) = \\frac{(b t)^ne^{-b t}}{n!}.\\]\n\nBy the above exercise, the assumption that the probability of a birth in a short interval of time is proportional to the length of the interval leads to the births having a Poisson distribution with rate \\(bt\\).\nNow let \\(T(t)\\) be the probability that the next birth event happens within a time \\(t\\). That is, \\(T\\) is the c.d.f. for the inter-event times. This is simply the probability there is at least one birth in the interval \\((0,t)\\), thus, \\(T(t) = 1-p_0(t) = 1-e^{bt}\\). This connection between the exponential and Poisson distributions will turn out to be useful in modelling and simulation."
  },
  {
    "objectID": "lec01-BirthProcess.html#many-individuals",
    "href": "lec01-BirthProcess.html#many-individuals",
    "title": "1  The Simple Death Process",
    "section": "2.2 Many individuals",
    "text": "2.2 Many individuals\nIn a population of a \\(n\\) individuals, \\[\\begin{align*}\n  \\hbox{Pr}\\{\\hbox{1 birth in $[t,t+\\tau]$}\\} &= nb\\tau(1-b\\tau)^{n-1} = nb\\tau + o(\\tau), \\\\\n  \\hbox{Pr}\\{\\hbox{more than 1 birth in $[t,t+\\tau]$}\\} &= \\begin{pmatrix} n\\\\m \\end{pmatrix}(b\\tau)^m(1-b\\tau)^{n-m} = o(\\tau), \\\\\n  \\hbox{Pr}\\{\\hbox{no births in $[t,t+\\tau]$}\\} &= 1 - nb\\tau + o(\\tau),\n\\end{align*}\\]\n\n2.2.1 The ODE for the mean\nThe master equation for the process relates the probabilities at each time step. \\[\\begin{align*}\n  p_n(t+\\tau) &= p_{n-1}(t)\\cdot\\hbox{Pr}\\{\\hbox{1 birth in $[t,t+\\tau]$}\\}+p_n(t)\\cdot\\hbox{Pr}\\{\\hbox{no births in $[t,t+\\tau]$}\\} \\\\\n              &= p_{n-1}(t)(n-1)b\\tau + p_n(t)(1-bn\\tau)+o(\\tau)\n\\end{align*}\\] Rearranging the master equation yields \\[\\begin{equation*}\n  \\frac{1}{\\tau}\\left(p_n(t+\\tau)-p_n(t)\\right) = b\\left((n-1)p_{n-1}(t)-np_n(t) \\right)\n\\end{equation*}\\]\nTaking a limit leads to a sequence of ODEs, \\[\\begin{equation*}\n  \\frac{d}{dt}p_n(t) = b\\left((n-1)p_{n-1}(t)-np_n(t) \\right), \\quad n\\in\\{n_0,n_0+1,\\dots, \\quad P_{n_0-1}=0\\},\n\\end{equation*}\\] with initial conditions \\[p_n(0) = \\begin{cases} 1 & \\text{if $n=n_0$,} \\\\ 0 & \\text{otherwise.} \\end{cases}\\]\nA differential equation for the mean and variance of the process can be derived from the above system.\n\\[\\begin{align*}\n  \\frac{dM_1}{dt} = \\sum_{n=1}^\\infty n\\dot{p}_n &= \\sum_{n=1}^\\infty bn\\left ( n-1)p_{n-1} - np_n\\right) \\\\\n         &= b\\sum_{n=0}^\\infty \\left( (n+1)np_n - n^2p_n \\right) \\\\\n         &= b\\sum_{n=1}^\\infty np_n  \\\\\n     &= bM_1\n\\end{align*}\\] with the initial condition \\(M_1(0) = n_0\\).\nThis equation has the solution \\[M_1(t) = n_0e^{bt}\\]\n\\[\\begin{align*}\n  \\frac{d\\sigma^2}{dt} = \\dfrac{d}{dt}\\left(M_2-M_1^2\\right) &= \\sum_{n=1}^\\infty n^2\\dot{p}_n - 2M_1\\frac{dM_1}{dt} \\\\\n      &= \\sum_{n=1}^\\infty bn^2\\left((n-1)p_{n-1}(t) - np_n(t)\\right) - 2bM_1^2 \\\\\n      &= \\sum_{n=1}^\\infty b\\left((n+1)^2np_{n}(t) - n^3p_n(t)\\right) - 2bM_1^2 \\\\\n      &= \\sum_{n=1}^\\infty b\\left((2n^2+n)p_{n}(t) \\right) - 2bM_1^2 \\\\\n      &= b\\left(2M_2+M_1  - 2M_1^2\\right) \\\\\n      &= 2b\\sigma^2+bM_1\n\\end{align*}\\] The initial conditions are \\(\\sigma^2(0)=0\\) and \\(M_1(0)=0\\), which leads to the solution \\[\\sigma^2(t) = n_0e^{bt}(e^{bt}-1)\\]"
  },
  {
    "objectID": "00-lab-R-intro.html#obtaining-and-installing-r",
    "href": "00-lab-R-intro.html#obtaining-and-installing-r",
    "title": "2  Introduction to R",
    "section": "2.1 obtaining and installing R",
    "text": "2.1 obtaining and installing R\n\nFollow instructions on the r-project website\nAlternately, download and set up R studio"
  },
  {
    "objectID": "00-lab-R-intro.html#getting-help",
    "href": "00-lab-R-intro.html#getting-help",
    "title": "2  Introduction to R",
    "section": "2.2 Getting help",
    "text": "2.2 Getting help\n\nfor help for on any command type ?command at the prompt. For example ?rbinom will give you a summary of the command for generating a string of random numbers from a binomial distribution. (See https://www.r-project.org/help.html for more details.)\nIf you have a graphical interface, there is probably also a HELP button.\nand of course you will want to keep the r manuals https://cran.r-project.org/manuals.html close at hand"
  },
  {
    "objectID": "00-lab-R-intro.html#simulating-a-simple-stochastic-process",
    "href": "00-lab-R-intro.html#simulating-a-simple-stochastic-process",
    "title": "2  Introduction to R",
    "section": "2.3 Simulating a simple stochastic process",
    "text": "2.3 Simulating a simple stochastic process\nTo start, we will use R to generate some sample paths from a simple stochastic process. Let \\(N(t)\\) be the number of individuals in the population at time \\(t\\), \\(t\\in\\{0,1,\\dots\\}\\), and suppose in any given time step, any given individual will give birth with probability \\(b\\). We will need a vector to store our resulting populations, and we should specify the length of this vector in advance. We also need some initial population, say \\(N(0) = N_0\\). First, set up a vector to hold the results.\n\n\nCode\nT = 10\nNo = 20\nN = rep(0,length=T)\n\n\nrep stands for replicate. The result is a vector of zeros of length \\(T\\).\nNext, initialize the first entry of \\(N\\) with initial value for the simulation.\n\n\nCode\nN[1] = No\n\n\nWe next want to generate some births. Since we’ve assumed all individuals are reproducing independently, we model the number of births in the first time interval by a binomial distribution with parameters \\(N\\) and \\(b\\). We assign a value to \\(b\\) and then use R’s rbinom command.\n\n\nCode\nb = .2\nbirths = rbinom(1,N[1],b)\n\n\nTo repeat this for the rest of the times, we set up a loop.\n\n\nCode\nfor (t in 1:(T-1)) {\n  N[t+1] = N[t] + rbinom(1,N[t],b)\n}\n\n\nR is built to work with vectors. It is just as easy, and surprisingly, almost as quick to generate many many sample paths as it is to generate one. To store the results, we set up a matrix with \\(S\\) columns, where \\(S\\) is the number of sample paths. The resulting code is as follows.\n\n\nCode\n T = 10\n S = 5\n N = matrix(0,nrow = T, ncol = S)\n N[1,] = 20\n b = .2\n for (t in 1:(T-1)) {\n     N[t+1,] = N[t,] + rbinom(S,N[t,],b)\n   }\n\n\nThe third line sets up a matrix with T rows, and S columns and fills it with zeros.\nThe fourth line initializes the first row of the matrix with initial values for the simulations. Note the slight difference from matlab’s notation.\nNotice the first argument to rbinom is the number of times we sample the binomial distribution.\nIf you type N again, you will see that the numbers increase as you move down the columns of the matrix. Each column represents on sample path of our simulation.\n\n\nCode\nhead(N)\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   20   20   20   20   20\n[2,]   26   22   23   25   24\n[3,]   32   26   27   29   30\n[4,]   38   34   37   35   36\n[5,]   48   44   41   43   43\n[6,]   61   52   49   51   53\n\n\nThis is all very nice, but for larger simulations, it just won’t do to look at the matrix of numbers. We need some plots. Here are a few useful ones to start with\n\nplot the first column against the row number plot(N[,1])\nadd some axis labels and a nice title\n\n\n\nCode\nplot(N[,1], \n     xlab=\"Time\",ylab=\"Population, N\",\n     main=\"One sample path of the simple birth process\"\n         )\n\n\n\n\n\n\nit is also possible to add the title and labels after creating the plot:\n\n\n\nCode\nplot(N[,1],ann=FALSE) \ntitle(xlab=\"Time\",\nylab=\"Population, N\", \nmain=\"One sample path of the simple birth process\")\n\n\n\n\n\nNotice that we needed to pass `ann=FALSE` to the plot command to suppress the default axis labels\n\nof course you might have noticed that the time axis isn’t really the time, it is the index of the row. What we really want is to start at t=0. What we can do is set up a vector times that contains the times corresponding to each index and pass that to the plot routine. In this case this is just a shift down by 1.\n\n\n\nCode\ntimes = 1:T - 1\nplot(times,N[,1],ann=FALSE) \ntitle(xlab=\"Time\", \nylab=\"Population, N\", \nmain=\"One sample path of the simple birth process\")\n\n\n\n\n\n\nplot all the columns on a single plot\n\n\n\nCode\nmatplot(times,N,ann=FALSE)\ntitle(xlab=\"Time\", \n  ylab=\"Population, N\", \n  main=\"Many sample paths of the simple birth process\")\n\n\n\n\n\n\nplot the first, third and fifth columns on a single plot\n\n\n\nCode\nmatplot(times,N[,c(1,3,5)],ann=FALSE)\ntitle(xlab=\"Time\", \n  ylab=\"Population, N\", \n  main=\"Many sample paths of the simple birth process\")\n\n\n\n\n\nThese values for the initial population and the probability of a birth in unit time are both too high for longer simulations. Change them to something more reasonable, and rerun the code with larger S and T, say 20 and 1000.\nBut wait, we don’t want to be typing everything in again every time we change parameters. That’s just crazy. What we do is wrap the whole thing up as a function and put it in a script. Save the following as a file, call it birthprocess.R, or whatever you like.\n\n\nCode\nbirthprocess = function(b = 0.01, No = 2, T = 200, S = 10) {\n    N = matrix(0.0,nrow = T, ncol = S)\n    N[1,] = No\n    for (t in 1:(T-1)) {\n        N[t+1,] = N[t,] + rbinom(S,N[t,],b)\n      }\n    return(N)\n}\n\n\nNotice that we have assigned default values to the arguments of the function. This isn’t necessary, but it can be useful.\nTo source our script from a prompt, enter source(\"birthprocess.R\")\nYou may need to explore your filesystem to learn where you saved the file to. Use the command getwd() to find out what your working directory is.\nTo call our function and assign the results to the matrix N we enter the following at the prompt\n\n\nCode\nN = birthprocess(b=0.02,No=2,T=1000,S=20)\n\n\nBy default, a function in R returns the value of the last evaluated expression. This seems to mean the use of the return statement is a matter of preference."
  },
  {
    "objectID": "00-lab-R-intro.html#prettier-plots-with-rs-basic-plot-functions",
    "href": "00-lab-R-intro.html#prettier-plots-with-rs-basic-plot-functions",
    "title": "2  Introduction to R",
    "section": "2.4 prettier plots (with R’s basic plot functions)",
    "text": "2.4 prettier plots (with R’s basic plot functions)\nIf we want to put more than two or three sample paths on a single plot, then we need a way to shrink the point size. There are a few ways to do this. The simplest for our purposes is to set the pch option to something else, like a dot instead of a circle.\n\n\nCode\ntimes = 0:(dim(N)[1]-1)\nmatplot(times,N, pch=\".\",ann=FALSE)\ntitle(xlab=\"Time\", \n      ylab=\"Population, N\", \n      main=\"Many sample paths of the simple birth process\")\n\n\n\n\n\nTo change to a log scale, use the log option which you can set to either log=\"x\" or log=\"y\":\n\n\nCode\nmatplot(times,N[,], pch=\".\", log = \"y\",ann=FALSE)\n\n\n\n\n\nIf you don’t have lots and lots of points, the dots might not show up. you can try o or * or some other symbol. Try each of these variations and see if you can deduce the meaning of the options\n\n\nCode\nmatplot(times,N, col=1, lty = \"dashed\", type=\"l\",log = \"y\")\n\n\n\n\n\n\n\nCode\nmatplot(times,N,ann=FALSE, \n        col=c(\"red\",\"green\",\"blue\"), \n  lty = c(\"dashed\",\"dotdash\"), \n  type=\"l\",\n  log = \"y\")\n\n\n\n\n\n\n\nCode\nmatplot(times,N,ann=FALSE,\n        col=c(\"red\",\"green\",\"blue\"), \n  lty = \"393C3F\",\n  type=\"l\",\n  log = \"y\")\n\n\n\n\n\nThere are several ways to add things to plots.\nYou can try the lines or curves functions. For example:\n\n\nCode\nlines(times,No*exp(b*times))\n\n\nadds an exponential curve to the plot.\n\n\nCode\n    curve(No*exp(b*x),add=TRUE)\n\n\nDoes the same thing.\nYou can make the line thicker.\n\n\nCode\n    lines(times,No*exp(b*times),lwd=2)\n\n\nOr you can make it a red, double-dashed line.\n\n\nCode\n    lines(times,No*exp(b*times),lwd=2,lty=\"twodash\",col='red')\n\n\nNote that the variants matpoints and matlines will also add points and lines to existing plots. These are probably equivalent to adding add=TRUE to matplot."
  },
  {
    "objectID": "00-lab-R-intro.html#prettier-plots-with-ggplot",
    "href": "00-lab-R-intro.html#prettier-plots-with-ggplot",
    "title": "2  Introduction to R",
    "section": "2.5 Prettier plots with ggplot",
    "text": "2.5 Prettier plots with ggplot\nThe ggplot2 library provides a fancier plotting interface. To use the package, we need to mangle our data into a long format. You could use the tidyr package, but for now, lets play a bit with data frames and rep.\nAssuming we have our data in the matrix N whose columns are separate simulations, we rearrange it into a long format as follows.\n\n\nCode\nT = dim(N)[1]\nS = dim(N)[2]\ndf = data.frame(\n       time = rep(1:T, times=S), \n           run = as.factor(rep(1:S,each=T)),\n             population = as.vector(N)\n             )\n\n\nThe times and each arguments to rep indicate the number of times to replicate the vectors 1:T and 1:S. One instance repeats the entire vector S times and the other repeats each element T times. as.factor essentially adds some information to the vector run so that ggplot will treat the entries as factors. We’ll see why when we play with the plots. as.vector simply treats the data in the matrix N as if it were a vector. R stores matrices in column-order, so this effectively stacks the columns into one long vector of length TxS.\nUse str(df) to see the structure of the data frame df\n\n\nCode\nstr(df)\n\n\n'data.frame':   20000 obs. of  3 variables:\n $ time      : int  1 2 3 4 5 6 7 8 9 10 ...\n $ run       : Factor w/ 20 levels \"1\",\"2\",\"3\",\"4\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ population: num  2 2 2 2 2 2 2 2 2 2 ...\n\n\nIf this is your fist use of ggplot you may need to install the package. Use Rstudio’s graphical interface, or try install.packages(\"ggplot2\") if you aren’t using a fancy interface.\nFirst we’ll source the package. Then create a simple plot.\n\n\nCode\nlibrary(ggplot2)\n\nggplot(df,aes(x=time,y=population)) + \n    geom_line(aes(col=run)) +\n    scale_y_continuous(trans=\"log10\")\n\n\n\n\n\nggplot builds the plot up in layers. The ggplot call inputs the data and sets up the aesthetics. I.e., which columns are used. The call to goem_line instructs ggplot to colour the curves according to the factor run. ggplot is powerful, but with power comes complication."
  },
  {
    "objectID": "01-lab-BirthProcess.html#initial-set-up",
    "href": "01-lab-BirthProcess.html#initial-set-up",
    "title": "3  The GillespieSSA routines",
    "section": "3.1 Initial set up",
    "text": "3.1 Initial set up\nOnce you’ve played around a bit, start up a new session and load up the Gillespie routines\n\n\nCode\nlibrary(GillespieSSA2)\n\n\nYou may need to install the package first. See me if you need help with that."
  },
  {
    "objectID": "01-lab-BirthProcess.html#the-simple-birth-death-process",
    "href": "01-lab-BirthProcess.html#the-simple-birth-death-process",
    "title": "3  The GillespieSSA routines",
    "section": "3.2 The simple birth death process",
    "text": "3.2 The simple birth death process\nLet’s start with the simple birth death process. This consists of a single state, which we’ll call population, and two transitions, or events: birth and death.\nOur model consists of specifying functions for the rates for the two events.\nFirst, focus on a single individual and suppose this individual gives birth at rate \\(b\\) and dies at rate \\(d\\). For simplicity, suppose the new born individual behaves exactly as the first individual. In particular, she is born a reproductive adult.\nIn a population of \\(N\\) such organisms, operating independently, births would occur at rate \\(bN\\) and deaths at rate \\(dN\\).\nOur model has a single state variable, which we’ll call population, and a two parameters: a birth rate b, and a death rate d. We also need to set a starting value for the population, which we often view as another parameter (the initial state).\nIt is convenient to use named tuples to store defaults for the parameters and initial states.\n\n\nCode\ninitial_state &lt;- c(population = 1)\nparams &lt;- c(b = 0.10, d = 0.02)\n\n\nThe SSA algorithm needs the model expressed in terms of reactions and rates, which the GillespieSSA2 package refers to as propensity functions. We have two of these: one for birth and one for death.\n\n\nCode\nreactions &lt;- list(\n  # propensity function     effects             name for reaction\n  reaction(\"b * population\", c(population = +1), \"birth\"),\n  reaction(\"d * population\", c(population = -1), \"death\")\n)\n\n\nTo run the simulation, we call ssa with the initial state, reactions, parameters, and a final time. There are several other options you can pass to the routine, but these all have reasonable defaults. There are a few options for expressing the rate, or propensity function. The simplest is likely to enter it as a c++ expression wrapped in quotes.\n\n\nCode\nout &lt;- ssa(\n  initial_state = initial_state,\n  reactions = reactions,\n  params = params,\n  method = ssa_exact(),\n  final_time = 100,\n  census_interval = .001,\n  verbose = TRUE\n  )\n\n\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nSSA finished!\n\n\nCode\nplot_ssa(out)\n\n\nLoading required namespace: ggplot2\n\n\n\n\n\nOur simulation run is now stored in out. Entering names(out) or summary(out) at the command prompt shows what the simulation returns. head(out$time) and head(out$state) show the first few events. plot_ssa provides a basic plot of the results."
  },
  {
    "objectID": "01-lab-BirthProcess.html#density-dependent-rates",
    "href": "01-lab-BirthProcess.html#density-dependent-rates",
    "title": "3  The GillespieSSA routines",
    "section": "3.3 Density dependent rates",
    "text": "3.3 Density dependent rates\nA simple extension of this to include a density dependence is to make the death rate nonlinear. For example, replace the constant per capita death rate \\(d\\) with the linearly increasing rate \\(d + (b-d)N/K\\).\nQuestion: what is the value of \\(N\\) for which the birth rate \\(bN\\) matches the death rate \\(\\left( d + (b-d)\\frac{N}{K} \\right) N\\)?\n\n\nCode\ninitial_state &lt;- c(population = 1)\nparams &lt;- c(b = 0.10, d = 0.01, K = 100)\nreactions &lt;- list(\n  # propensity function                          effects             name for reaction\n  reaction(\"b * population\",                      c(population = +1), \"birth\"),\n  reaction(\"(d+(b-d)*population/K) * population\", c(population = -1), \"death\")\n)\n\nout &lt;-\n  ssa(\n    initial_state = initial_state,\n    reactions = reactions,\n    params = params,\n    method = ssa_exact(),\n    final_time = 100,\n    census_interval = .001,\n    verbose = TRUE\n  )\n\n\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nSSA finished!\n\n\nCode\nplot_ssa(out)"
  },
  {
    "objectID": "01-lab-BirthProcess.html#the-lotka-voltera-predator-prey-model",
    "href": "01-lab-BirthProcess.html#the-lotka-voltera-predator-prey-model",
    "title": "3  The GillespieSSA routines",
    "section": "3.4 The Lotka-Voltera predator-prey model",
    "text": "3.4 The Lotka-Voltera predator-prey model\nModels can easily be extended to add multiple state variables.\nOne possible implementation of the Lotka-Volterra predator-prey model is to define two state variables, prey and predator, and three reactions, prey birth, predation, and predator death.\n\n\nCode\ninitial_state &lt;- c(prey = 1000, predators = 1000)\nparams &lt;- c(c1 = 10, c2 = 0.01, c3 = 10)\nreactions &lt;- list(\n  #        propensity function     effects                       name for reaction\n  reaction(\"c1 * prey\",             c(prey = +1),                 \"prey_birth\"),\n  reaction(\"c2 * prey * predators\", c(prey = -1, predators = +1), \"predation\"),\n  reaction(\"c3 * predators\",        c(predators = -1),            \"predator_death\")\n)\n\nout &lt;-\n  ssa(\n    initial_state = initial_state,\n    reactions = reactions,\n    params = params,\n    method = ssa_exact(),\n    final_time = 5,\n    census_interval = .001,\n    verbose = TRUE\n  )\n\n\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000003999, sim_time: 1.68572\nwalltime: 2007829030, sim_time: 3.49854\nSSA finished!\n\n\nCode\nplot_ssa(out)\n\n\n\n\n\nNow we’d really like to sample several solutions from the model to get some idea of the variability. There are many ways to do this. We’ll start by using a fairly simple data frame and a for loop.\n\n\nCode\nres_pred_prey = as.data.frame(NULL)\nsamples = 5\nfor (run in 1:samples) {\n    out &lt;-\n        ssa(\n            initial_state = initial_state,\n            reactions = reactions,\n            params = params,\n            method = ssa_exact(),\n            final_time = 5,\n            census_interval = .001,\n            verbose = TRUE\n        )\n    res_pred_prey = rbind(\n      res_pred_prey,\n        data.frame(\n          time = out$time,\n            prey = out$state[,'prey'],\n            predator = out$state[,'predators'],\n            run = as.factor(run)\n        )\n    )\n}\n\n\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000010422, sim_time: 1.79524\nwalltime: 2000013177, sim_time: 3.5951\nSSA finished!\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000011435, sim_time: 1.79079\nwalltime: 2000006050, sim_time: 3.55881\nwalltime: 3000004221, sim_time: 4.49554\nSSA finished!\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000005464, sim_time: 1.84971\nwalltime: 2000022277, sim_time: 3.65765\nSSA finished!\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000000310, sim_time: 1.8001\nwalltime: 2000009342, sim_time: 3.61428\nSSA finished!\nRunning SSA exact with console output every 1 seconds\nwalltime: 0, sim_time: 0\nwalltime: 1000011220, sim_time: 1.7383\nwalltime: 2000011262, sim_time: 3.50501\nSSA finished!\n\n\nNote the use of data.frame at the end of each loop to wrap each simulation result in a data frame with four columns. Then the use of rbind to append the new data frame to the previous one. The first line sets up an empty data frame (NULL) to start with.\nThe ggplot2 library provides some powerful plotting tools.\n\n\nCode\nlibrary(ggplot2)\n\nggplot(res_pred_prey,aes(x=time,y=prey)) +\n  geom_step(aes(col=run))\n\n\n\n\n\nCode\ndev.new()\nggplot(res_pred_prey,aes(x=time,y=predator)) +\n  geom_step(aes(col=run))\n\n\nNotice ggplot wants the data in a long format. The easiest way to reshape dataframes is with the tidyr package. You can install this on its own or as part of the tidyverse package.\n\n\nCode\nlibrary(tidyr)\n\nhead(res_pred_prey)\n\n\n         time prey predator run\n1 0.000000000 1000     1000   1\n2 0.001064755 1003      996   1\n3 0.002036914 1007      991   1\n4 0.003005564 1007      990   1\n5 0.004053445 1007      986   1\n6 0.005002070 1014      979   1\n\n\nCode\nres_long = gather(res_pred_prey,species,population,predator:prey,factor_key=TRUE)\nhead(res_long)\n\n\n         time run  species population\n1 0.000000000   1 predator       1000\n2 0.001064755   1 predator        996\n3 0.002036914   1 predator        991\n4 0.003005564   1 predator        990\n5 0.004053445   1 predator        986\n6 0.005002070   1 predator        979\n\n\nThe second and third inputs of gather are the column names for the long format, and the fourth input is the range of columns from the wide data frame (res_pred_prey) to reshape.\nWe can use ggplot to assign colours and line-types by run and species\n\n\nCode\nggplot(res_long,aes(x=time,y=population,linetype=run,col=species)) + geom_step()\n\n\n\n\n\nThe result is interesting, but probably too much for one plot. We can put each plot in a panel using facet_grid or facet_plot.\n\n\nCode\nggplot(\n    res_long,\n    aes(x=time,y=population,col=species)\n    ) + \ngeom_step() +\nfacet_wrap(~run)"
  },
  {
    "objectID": "02-lab-SDE.html#τ-leaping",
    "href": "02-lab-SDE.html#τ-leaping",
    "title": "4  The stochastic difference equations and analogous deterministic equations",
    "section": "4.1 τ-leaping",
    "text": "4.1 τ-leaping\nAs populations get larger, inter-event times get shorter and simulations using the Gillespie-SSA can be time-consuming. One method to speed up computations, at the expense of some of the exactness of the Gillespie algorithm, is to take fixed time steps of some length \\(\\tau\\) and approximate the number of events as a Poisson random variable.\nConsider again the simple birth process with rate \\(b\\). We found the number of births in a time \\(t\\) was a Poisson random variable with parameter \\(bt\\). These results are easy to extend to the nonlinear birth-death process (see Allen 2011). To simplify our previous notation, suppose \\(b_n\\) and \\(d_n\\) are the birth and death rates given a current population size \\(n\\). Thus in a (vanishingly) small time interval \\(\\tau\\), a single birth occurs with probability \\(b_n\\tau + o(\\tau)\\), a single death occurs with probability \\(d_n\\tau + o(\\tau)\\), a combination of the two events occurs with probability \\(o(\\tau)\\), and neither event occurs with probability \\(1 - (b_n + d_n)\\tau + o(\\tau)\\). Allowing a longer time step, still denoted by \\(\\tau\\), the number of births and deaths occurring during the step are Poisson random variables with rates \\(b_n\\tau\\) and \\(d_n\\tau\\) respectively.\nTo illustrate, use our logistic birth-death process with \\(b_n = bn\\) and \\(d_n = (d+cn)n\\). We’ll refer to \\(b_n\\) and \\(d_n\\) as the birth and rates and to \\(b\\) and \\(d\\) as the per-capita birth and death rates.\nFirst, set up the birth and death rates and pick some parameters.\n\n\nCode\nbirths = function(n) b*n\ndeaths = function(n) (d+((b-d)/K)*n)*n\nb = 0.01\nd = 0.006\nK=500\nNo = 10\n\n\nWith these rates, we should expect on average 5 births and 5 deaths per unit time at a population of 500. If we take a step size of 20 time units, we expect 100 births and 100 deaths on average. This may seem large, but the standard deviation of the Poisson distribution with mean 100 is 10.\n\n\nCode\nstepsize = 20\ntimes = seq(0,by=stepsize,length=100)\nsamples = 20\nN = matrix(0,nrow=length(times),ncol=samples)\nN[1,] = No\n\n\nNow we’ve set up a sequence of times and a matrix to hold the results for 20 sample paths. A simple for loop can be used to fill in the rows of n.\n\n\nCode\nfor (i in 2:(length(times))) {\n  newbirths = pmax(0,births(N[i-1,])*stepsize)\n  newdeaths = pmax(0,deaths(N[i-1,])*stepsize)\n  N[i,] =  N[i-1,] + rpois(samples,newbirths) - rpois(samples,newdeaths)\n}\n\nmatplot(times,N)\n\n\n\n\n\nCreating a heatmap-like image of the results is another good visualization trick, especially for larger samples.\n\n\nCode\nbreaks = seq(0,1.5*K,length=13)\nbreaks[1] = min(N,na.rm=TRUE)\nbreaks[13] = max(N,na.rm=TRUE)\nH = matrix(0,nrow=length(times),ncol=12)\n\nfor (i in 1:length(times)) { \n    H[i,] = hist(N[i,],breaks=breaks,plot=FALSE)$counts \n}\n\nimage(H)\n\n\n\n\n\nDo a few sanity checks before running the for loop. Make sure the breaks do cover the range of N, and that the number of breaks is 12, which is assumed in initializing H.\nTo compare with the results of the Gillespie SSA, compute a few sample paths that way.\n\n\nCode\nlibrary(GillespieSSA2)\ninitial_state &lt;- c(population = No)\nparams &lt;- c(b = b, d = d, K = K)\nreactions &lt;- list(\n  # propensity function                          effects             name for reaction\n  reaction(\"b * population\",                      c(population = +1), \"birth\"),\n  reaction(\"(d+(b-d)*population/K) * population\", c(population = -1), \"death\")\n)\n\nNssa = matrix(0,nrow=length(times),ncol=samples)\nfor (i in 1:samples) {\nout &lt;-\n  ssa(\n    initial_state = initial_state,\n    reactions = reactions,\n    params = params,\n    method = ssa_exact(),\n    final_time = times[length(times)],\n    census_interval = stepsize,\n        log_buffer=TRUE,\n    verbose = FALSE\n  )\nNssa[1:length(out$state),i] = out$state\n}\n\n\nbreaks[1] = min(Nssa,na.rm=TRUE)\nbreaks[12] = max(Nssa,na.rm=TRUE)\nHssa = matrix(0,nrow=length(times),ncol=12)\nfor (i in 1:length(times)) { Hssa[i,] = hist(Nssa[i,],breaks=breaks,plot=FALSE)$counts }\n\nimage(Hssa)\n\n\n\n\n\nτ-leaping can be done with the ssa routines. Details can be found in help pages for ssa_exact, ssa_etl and ssa_btl."
  },
  {
    "objectID": "02-lab-SDE.html#continuous-state-approximations",
    "href": "02-lab-SDE.html#continuous-state-approximations",
    "title": "4  The stochastic difference equations and analogous deterministic equations",
    "section": "4.2 Continuous state approximations",
    "text": "4.2 Continuous state approximations\nWhen \\(\\lambda\\) is large, the normal distribution with mean \\(\\lambda\\) and variance \\(\\lambda\\) is a reasonable approximation to the Poisson distribution with rate \\(\\lambda\\). Better still, if \\(B\\) and \\(D\\) are normally distributed random variables with means \\(\\mu_b\\) and \\(\\mu_d\\), and variances \\(\\sigma_b^2\\) and \\(\\sigma_d^2\\) respectively, then the difference, \\(B-D\\), has a normal distribution with mean \\(\\mu_b-\\mu_d\\) and variance \\(\\sigma^b+\\sigma^2_d\\).\n\n\nCode\nfor (i in 2:(length(times))) {\n  rate_b = births(N[i-1,])*stepsize\n  rate_d = deaths(N[i-1,])*stepsize\n  N[i,] =  N[i-1,] + rate_b-rate_d + sqrt(rate_b+rate_d)*rnorm(samples,0,1)\n}"
  },
  {
    "objectID": "02-lab-SDE.html#the-analogous-differential-equation",
    "href": "02-lab-SDE.html#the-analogous-differential-equation",
    "title": "4  The stochastic difference equations and analogous deterministic equations",
    "section": "4.3 The analogous differential equation",
    "text": "4.3 The analogous differential equation\nLet \\(N(t)\\) be the random variable denoting the population at time \\(t\\), let \\(dt\\) denote our stepsize, and set \\(dN(t) = N(t+dt) - N(t)\\). This lets us write the stochastic difference equation in the last code snippet as \\[ dN = (B(N)-D(N))dt + dW\\] with \\(dW\\) a normally distributed random variable with mean zero and variance \\((B(N)-D(N))dt\\). Taking a limit as \\(dt\\to0\\) leads us into the realm of stochastic differential equations. Linda Allen (Allen 2011) gives a nice treatment of these in the context of biological applications. Our treatment here will be simpler: we’ll ignore \\(dW\\) and just look at the simpler differential equation.\n\\[\\frac{d}{dt}N = B(N) - D(N)\\]\nIn the case of our logistic birth and death rates, this is\n\\[\\frac{d}{dt}N = rN(1-N/K)\\] with \\(r = b-d\\)\nAs an exercise, solve this separable differential equation via the trick of integrating \\[\\int \\frac{1}{N(1-N/K)}\\, dN = \\int r\\, dt\\] and add the solution to the plot of the stochastic simulation results computed earlier.\n\n\n\n\nAllen, Linda J. S. 2011. An Introduction to Stochastic Processes with Applications to Biology. CRC Press. https://unb.on.worldcat.org/oclc/908670270."
  }
]